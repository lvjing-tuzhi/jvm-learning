# 1、JVM的体系结构

![未命名文件](D:\笔记\java\jvm\jvm入门.assets\未命名文件.png)

# 2、类加载器

> 1. 类(引用类型)在栈里面，对象在堆里面，栈是引用地址。
> 2. 常用类lang包在rt.jar中，扩展的在jre>lib>ext

## 1、类加载器流程

1. 装载：查找和导入Class文件。

2. 链接：

   * 检查：检查载入的Class文件数据的正确性。包括了四种验证：
     * 文件格式验证：是否以OxCAFEBABE开头，版本号是否合理。
     * 元数据验证：是否有弗雷，继承了final类？非抽象类实现了所有的抽象方法。
     * 字节码验证：运行检查，栈数据类型和操作码参数吻合，跳转指令到合理的位置。
     * 符号引用验证：常量池中描述类是否存在，访问的方法或字段是否存在有足够的权限。
   * 准备：给类的静态变量分配存储空间。
   * 解析：将符号引用转成直接引用。
   * 初始化：对静态变量，静态代码块执行初始化工作。

   ![类加载器过程](D:\笔记\java\jvm\jvm入门.assets\类加载器过程-16440693924451.png)

## 2、加载器类型

1. 根加载器（Bootstrap）
2. 扩展类加载器（ExtClassLoader）
3. 应用加载器（系统加载器）（AppClassLoader）

## 3、双亲委派机制

加载类顺序：应用加载器>扩展类加载器>  根加载器，从这个顺序开始加载类，以后加载的类为准，例：自定义了一个String类，这个自定义的String类是位于应用加载器中，而根加载器也有一个自带的String方法类，所以最后会执行根加载器的String，执行不到自定义的String。

![双亲委派机制](D:\笔记\java\jvm\jvm入门.assets\双亲委派机制.png)

# 3、沙箱安全机制

1. Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

2. 所有的Java程序运行都可以指定沙箱，可以定制安全策略。

3. 在Java中将执行程序分别本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的，对于授权的本地代码，可以访问一切本地资源。而对于非授权的远程代码在早期的Java实现中，安全依赖于沙箱（Sandbox）机制。如下图JDK1.0安全模型。

   ![沙箱安全机制1](D:\笔记\java\jvm\jvm入门.assets\沙箱安全机制1.png)

4. 但如此严格的安全机制也给程序的功能扩展带来了障碍，比如当用户希望远程代码访问本地系统的文件袋时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型。

   ![沙箱安全机制2](D:\笔记\java\jvm\jvm入门.assets\沙箱安全机制2.png)

5. 在Java1.2版本中，再次改进了安全机制，增加了代码签名。无论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如所示的JDK1.2安全模型。

   ![沙箱安全机制3](D:\笔记\java\jvm\jvm入门.assets\沙箱安全机制3.png)

6. 当前最新的安全机制实现，则引入了域（Domain）的概念，虚拟机会把所有代码加载到不同系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不用的受保护域（Protected Domain），对应不一样的权限（Permission）。存在与不用域中的类文件就具有了当前域的全部权限，如下图所示的最新的安全模型（JDK1.6）。

   ![沙箱安全机制4](D:\笔记\java\jvm\jvm入门.assets\沙箱安全机制4.png)

## 1、组成沙箱的基本组件：

1. 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有类文件都会经过字节码校验，比如核心类。
2. 类装载器（ClassLoader）：其中类装载器在3个方面对Java沙箱起作用：
   * 它防止恶意代码取干涉善意代码（双亲委派机制）。
   * 它守护了被信任的类库边界。
   * 它将代码归入了保护域，确定了代码可以进行哪些操作。

类装载器采用的机制是双亲委派模式。

1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；
2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。

- `存取控制器`（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。

- `安全管理器`（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。

- ```
  安全软件包
  ```

  （security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：

  - 安全提供者
  - 消息摘要
  - 数字签名
  - 加密
  - 鉴别

































